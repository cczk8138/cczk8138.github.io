
 <!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  
    <title>一些零散的知识点 | 周二</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="取名很蛋疼">
    

    
    <meta name="description" content="macOS上测试远程推送的工具 空指针 和 野指针 空指针：不指向任何内存地址的指针，给空指针发任何消息不会任何问题，相当于 [nil xxx]; 野指针：指向一块被释放调的内存的指针，给野指针发消息会报异常，处理方法是将野指针置空：p = nil;   static 和 extern 的总结static  修饰全局变量时，全局变量只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互">
<meta name="keywords" content="零散">
<meta property="og:type" content="article">
<meta property="og:title" content="一些零散的知识点">
<meta property="og:url" content="https://cfap.github.io/2018/04/09/7788/index.html">
<meta property="og:site_name" content="周二">
<meta property="og:description" content="macOS上测试远程推送的工具 空指针 和 野指针 空指针：不指向任何内存地址的指针，给空指针发任何消息不会任何问题，相当于 [nil xxx]; 野指针：指向一块被释放调的内存的指针，给野指针发消息会报异常，处理方法是将野指针置空：p = nil;   static 和 extern 的总结static  修饰全局变量时，全局变量只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-04-27T11:10:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一些零散的知识点">
<meta name="twitter:description" content="macOS上测试远程推送的工具 空指针 和 野指针 空指针：不指向任何内存地址的指针，给空指针发任何消息不会任何问题，相当于 [nil xxx]; 野指针：指向一块被释放调的内存的指针，给野指针发消息会报异常，处理方法是将野指针置空：p = nil;   static 和 extern 的总结static  修饰全局变量时，全局变量只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互">

    
    <link rel="alternative" href="/atom.xml" title="周二" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.png">
    
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="周二">周二</a></h1>
				<h2 class="blog-motto">不做评论</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:cfap.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/04/09/7788/" title="一些零散的知识点" itemprop="url">一些零散的知识点</a>
  </h1>
  
  <p class="article-time">
    <time datetime="2018-04-09T10:00:38.000Z" itemprop="datePublished"> 发表于 2018-04-09 18:00:38</time>
    
  </p>
</header>
	<div class="article-content">
		<p><br></p>
<h3 id="macOS上测试远程推送的工具"><a href="#macOS上测试远程推送的工具" class="headerlink" title="macOS上测试远程推送的工具"></a><strong><a href="https://github.com/search?l=Objective-C&amp;o=desc&amp;q=push&amp;s=stars&amp;type=Repositories&amp;utf8=%E2%9C%93" target="_blank" rel="noopener">macOS上测试远程推送的工具</a></strong></h3><p><br><br><br></p>
<h2 id="空指针-和-野指针"><a href="#空指针-和-野指针" class="headerlink" title="空指针 和 野指针"></a>空指针 和 野指针</h2><ul>
<li>空指针：不指向任何内存地址的指针，给空指针发任何消息不会任何问题，相当于 [nil xxx];</li>
<li>野指针：指向一块被释放调的内存的指针，给野指针发消息会报异常，处理方法是将野指针置空：p = nil;</li>
</ul>
<p><br><br><br></p>
<h2 id="static-和-extern-的总结"><a href="#static-和-extern-的总结" class="headerlink" title="static 和 extern 的总结"></a>static 和 extern 的总结</h2><p><code>static</code></p>
<ul>
<li>修饰全局变量时，全局变量只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰</li>
<li>修饰函数时，该函数为内部函数，只能在定义该函数的文件中使用。不同的文件中可以有同名的内部函数，则互不干扰。</li>
</ul>
<p><br><br><code>extern</code> （不管用来修饰 全局变量 还是 函数，extern 都可以省略）</p>
<ul>
<li>修饰全局变量时，只表示声明，不代表定义。多个源文件中同名的全局变量都代表着同一个变量</li>
<li>修饰函数时，该函数为内部函数，可供其他文件调用。调用其他文件中的外部函数，需在当前文件中用extern声明该外部函数，然后就可以使用</li>
<li>定义函数时省略 extern，则隐含为外部函数</li>
</ul>
<p><br><br><br></p>
<h2 id="CoreGraphics-绘图"><a href="#CoreGraphics-绘图" class="headerlink" title="CoreGraphics 绘图"></a>CoreGraphics 绘图</h2><p>CGContextSaveGState 与 UIGraphicsPushContext 的区别</p>
<ul>
<li>CGContextSaveGState 和 CGContextRestoreGState 是保存和恢复上下文的绘制状态。</li>
<li>UIGraphicsPushContext(ctx) 和 UIGraphicsPopContext() 是对上下文做入栈出栈，入栈后上下文 ctx 就成了当前上下文</li>
</ul>
<p><br><br>Quartz 2D，是iOS和Mac OS X环境下的二维绘图引擎。<br>涉及内容包括：基于路径的绘图，透明度绘图，遮盖，阴影，透明层，颜色管理，防锯齿渲染，生成PDF，以及PDF元数据相关处理</p>
<p><br><br><br></p>
<h2 id="ipa-包的瘦身"><a href="#ipa-包的瘦身" class="headerlink" title="ipa 包的瘦身"></a>ipa 包的瘦身</h2><ul>
<li>删除没用到的类</li>
<li>删除没用到的图片，对图片资源进行无损压缩</li>
<li>编译选项优化，检查Xcode的设置的编译指令集是否有多余的可以删除</li>
<li>第三方库只用生产环境的，不要使用生产和调试环境都可用的库</li>
</ul>
<p><br><br><br></p>
<h2 id="KVO-amp-通知"><a href="#KVO-amp-通知" class="headerlink" title="KVO &amp; 通知"></a>KVO &amp; 通知</h2><ul>
<li>KVO</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)useKVO &#123;</span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:@&quot;无聊&quot;];</span><br><span class="line"></span><br><span class="line">    self.person.name = @&quot;李四&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// object：被观察的对象</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;name&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;旧值: %@       新值:%@&quot;, change[NSKeyValueChangeOldKey], change[NSKeyValueChangeNewKey]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 记得移除</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;name&quot; context:@&quot;无聊&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li>通知 NSNotification</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    // 通知</span><br><span class="line">    // 最后一个参数相当于二次校验，一般直接传 nil 。</span><br><span class="line">    // 当值为 nil 时，只要 name 相同就能接收通知；不为 nil 时，需要 name 和 object 两个都相同才会接收通知</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(test3:) name:@&quot;NotificationName&quot; object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    // 最后一个参数的作用是传递数据</span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;NotificationName&quot; object:@&quot;come_on&quot; userInfo:@&#123;@&quot;say&quot; : @&quot;hello~&quot;&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test1:(id)object &#123;</span><br><span class="line">    // 不会被调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test2:(id)object &#123;</span><br><span class="line">    // 不会被调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test3:(id)object &#123;</span><br><span class="line">    if ([object isKindOfClass:[NSNotification class]]) &#123;</span><br><span class="line">        // 会被调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 记得移除</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="TCP协议和UDP协议的差别"><a href="#TCP协议和UDP协议的差别" class="headerlink" title="TCP协议和UDP协议的差别"></a>TCP协议和UDP协议的差别</h2><table>
<thead>
<tr>
<th>比较</th>
<th>TCP协议</th>
<th>UDP协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否连接</td>
<td>面向连接</td>
<td>面向非连接 </td>
</tr>
<tr>
<td>传输可靠性</td>
<td>可靠</td>
<td>不可靠，易丢包 </td>
</tr>
<tr>
<td>应用场合</td>
<td>传输大量数据</td>
<td>少量数据 </td>
</tr>
<tr>
<td>速度</td>
<td>慢，传输前要经过3次握手</td>
<td>快</td>
</tr>
</tbody>
</table>
<p><br><br><br></p>
<h2 id="使用规范："><a href="#使用规范：" class="headerlink" title="使用规范："></a>使用规范：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 为了在 Swift 和 OC 混编时，让 Swift 编译器知道一个 OC 对象是可空还是不可空的，对基本类型无效</span><br><span class="line">* nonnull/nullable    不可空/可空</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>对于 OC 属性、方法返回值、方法参数的修饰，使用：<code>nonnull / nullable</code>；对于 C 函数的参数、Block 的参数、Block 返回值的修饰，使用：<code>_Nonnull / _Nullable</code>，建议弃用 <code>__nonnull / __nullable</code> 。</p>
<p><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 声明属性的修饰：</span><br><span class="line">@property (nonatomic, copy, nullable) NSString *aString;</span><br><span class="line">@property (nonatomic, copy) NSString * __nullable aString;</span><br><span class="line">@property (nonatomic, copy) NSString * _Nullable aString;</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 方法返回值修饰：</span><br><span class="line">- (nullable NSString *)method;</span><br><span class="line">- (NSString * __nullable)method;</span><br><span class="line">- (NSString * _Nullable)method;</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 方法参数修饰：</span><br><span class="line">- (void)methodWithString:(nullable NSString *)aString;</span><br><span class="line">- (void)methodWithString:(NSString * _Nullable)aString;</span><br><span class="line">- (void)methodWithString:(NSString * __nullable)aString;</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END之间，定义的所有对象属性和方法默认都是 nonnull</span><br></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><code>null_resettable</code>: <code>get</code>不能返回空, <code>set</code>可以为空（注意：如果使用 <code>null_resettable</code>，必须 重写<code>get</code>方法或者<code>set</code>方法，处理传递的值为空的情况）</li>
</ul>
<p><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 书写方式:</span><br><span class="line">@property (nonatomic, copy, null_resettable) NSString *name;</span><br></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><code>_Null_unspecified</code>:不确定是否为空</li>
</ul>
<p><br></p>
<h4 id="kindof"><a href="#kindof" class="headerlink" title="__kindof"></a>__kindof</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSArray&lt;UIView *&gt; *viewCollection;</span><br><span class="line">// 参数可以是 UIView 类型及其子类</span><br><span class="line">@property (nonatomic, strong) NSArray&lt;__kindof UIView *&gt; *viewCollection;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="深复制和浅复制？"><a href="#深复制和浅复制？" class="headerlink" title="深复制和浅复制？"></a>深复制和浅复制？</h2><ul>
<li>copy：返回不可变对象</li>
<li>mutableCopy：返回可变对象</li>
<li>不可变对象的不可变复制是浅复制，不产生新对象，只是被复制对象的引用计数加一；其他复制都是深复制。</li>
<li>这里的深复制，对于数组来说实际上只是单层深复制，只对数组本身进行深复制，元素还是浅复制</li>
<li>若要实现真正的多层深复制，要把对象先归档再解档；但如果是数组对象，还必须让数组元素实现 NSCopying 和 NSMutableCopying 协议</li>
<li>把一个不可变对象赋值给一个可变对象时，这个对象调用添加元素或者拼接字符串等方法时会报错，因为它的本质还是一个不可变对象</li>
</ul>
<p><code>[array mutableCopy];</code><br>只是对 <code>array</code> 进行了深复制，<code>array</code> 数组内部的元素只是指针的复制，属于浅复制</p>
<p>要想实现数组及其元素的完全深复制，需要数组元素对象实现 <code>NSCoding</code> 协议，并用归档、反归档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSData *data = [NSKeyedArchiver archivedDataWithRootObject:array];</span><br><span class="line">NSArray *array2 = [NSKeyedUnarchiver unarchiveObjectWithData:data];</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p><br></p>
<h4 id="initialize-和-load"><a href="#initialize-和-load" class="headerlink" title="initialize 和 load"></a>initialize 和 load</h4><p>区别在于：<code>load</code>是只要类有被编译到，则这个类不管有没有被其他文件引用、使用，都会调用这个类的<code>load</code>方法；而<code>initialize</code>是在类或者其子类的第一个方法被调用前调用。所以即使类文件被引用进来，但是没有使用，那么<code>initialize</code>也不会被调用。</p>
<p>相同点在于：方法都只会被调用一次，都是类方法。</p>
<p><br></p>
<h4 id="init"><a href="#init" class="headerlink" title="init:"></a>init:</h4><p>在此方法中初始化一些属性变量等，如果是 UIView 的 init：方法内部会调用 initWithFrame: 方法</p>
<p><br></p>
<h4 id="initWithFrame"><a href="#initWithFrame" class="headerlink" title="initWithFrame:"></a>initWithFrame:</h4><p>继承 UIView 的自定义控件，可重写此方法来初始化子控件</p>
<p><br></p>
<h4 id="initWithCoder"><a href="#initWithCoder" class="headerlink" title="initWithCoder:"></a>initWithCoder:</h4><p>当从 nib 文件中加载对象的时候，如果重写了此方法，系统会自动调用。</p>
<p><br></p>
<h4 id="loadView"><a href="#loadView" class="headerlink" title="loadView:"></a>loadView:</h4><ul>
<li>如果控制器重写了此方法，且没有使用 nib 视图页面，则系统会自动调用此方法，<code>不能自己调用</code>。</li>
<li>当 view 需要被展示而它却是 nil 时，控制器会调用该方法。</li>
<li>在此方法中创建 UIView 并赋值给 self.view，但是不能使用 [self.view addSubview:xxx]，因为此时 self.view 还是 nil，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)loadView &#123;</span><br><span class="line">    [super loadView];</span><br><span class="line">    </span><br><span class="line">    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 100, 100, 100)];</span><br><span class="line">    label.backgroundColor = [UIColor orangeColor];</span><br><span class="line">    </span><br><span class="line">    // 如果前面没调用 [super loadView]; 则 self.view 还是 nil ，调用下面这行代码添加控</span><br><span class="line">    // 件到 self.view，又会调用 loadView 方法，会陷入死循环</span><br><span class="line">    // 但是如果有[super loadView]; 则此时 self.view 已经不为空，调用下面这行代码没问题</span><br><span class="line">    // [self.view addSubview:label];</span><br><span class="line">    </span><br><span class="line">    self.view = label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="执行顺序："><a href="#执行顺序：" class="headerlink" title="执行顺序："></a>执行顺序：</h3><p>当视图 A 通过 push 切换到视图 B 时真实的调用顺序是：</p>
<p>1、B 视图 viewDidLoad<br>2、A 视图 viewWillDisappear<br>3、B 视图 viewVillAppear<br>4、A 视图 viewDidDisappear<br>5、B 视图 viewDidAppear</p>
<p><br><br><br></p>
<h2 id="UI-种类："><a href="#UI-种类：" class="headerlink" title="UI 种类："></a>UI 种类：</h2><ul>
<li>一进入界面的时的默认 UI</li>
<li>网络慢时正在加载的 UI</li>
<li>网络正常时的 UI（有时需要分 wifi 、 移动数据）</li>
<li>网络连接失败时的 UI</li>
<li>有网/无网，有GPS / 无GPS 等来回切换时，界面 UI 的显示情况</li>
<li>若正在执行动画时程序进入后台，再进入前台时要怎么显示</li>
</ul>
<p><br><br><br></p>
<h2 id="const-用法、值传递、地址传递、引用传递"><a href="#const-用法、值传递、地址传递、引用传递" class="headerlink" title="const 用法、值传递、地址传递、引用传递"></a>const 用法、值传递、地址传递、引用传递</h2><ul>
<li><strong>值传递不改变实参的值，地址传递和引用传递都会改变实参的值</strong>  </li>
<li><strong>引用传递和值传递除了形参写法不一样外，调用时的写法是一样的，如：Exchg1(a, b);  Exchg3(a, b);</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 值传递：调用时写法是 Exchg1(a, b);</span><br><span class="line">Exchg1(int x, int y)     </span><br><span class="line">  </span><br><span class="line">// 地址传递：调用时写法是 Exchg2(&amp;a, &amp;b);</span><br><span class="line">Exchg2(int *px, int *py)</span><br><span class="line">  </span><br><span class="line">// 引用传递：调用时写法是 Exchg3(a, b); 注意定义时的形式参数的格式与值传递不同</span><br><span class="line">Exchg3(int &amp;x, int &amp;y)</span><br></pre></td></tr></table></figure>
<p><br><br><code>注意: 在 const 之后的东西（*p 或者 p）是常量，不可变</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 效果是完全一样的，x 不可变</span><br><span class="line">const int x 和 int const x</span><br><span class="line">  </span><br><span class="line">// 效果不一样。前者 *p 不可变，p 可变；后者 p 不可变，*p 可变  </span><br><span class="line">const int *p 和 int *const p</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h4 id="去除前后的空格、换行"><a href="#去除前后的空格、换行" class="headerlink" title="去除前后的空格、换行"></a>去除前后的空格、换行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *string = @&quot;  \n   Hello  this  is a long   string!   \n   &quot;;</span><br><span class="line"></span><br><span class="line">// 去除前后的空格、换行（\n），以下代码输出的内容是 @&quot;Hello  this  is a long   string!&quot;</span><br><span class="line">string = [string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];</span><br></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// C 字符串转 OC 字符串</span><br><span class="line">// NSString *name = @(&quot;Jackey&quot;); 不建议？</span><br><span class="line">NSString *str = [NSString stringWithUTF8String:&quot;123abc&quot;];</span><br><span class="line"></span><br><span class="line">// OC 字符串转 C 字符串</span><br><span class="line">const char *s = [str cStringUsingEncoding:NSUTF8StringEncoding];</span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br><br><br></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/零散/">零散</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://cfap.github.io/2018/04/09/7788/" data-title="一些零散的知识点 | 周二" data-tsina="undefined" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2018/04/27/NSAttributedString/" title="NSAttributedString 属性文本（图文混排）">
  <strong>上一篇：</strong><br/>
  <span>
  NSAttributedString 属性文本（图文混排）</span>
</a>
</div>


<div class="next">
<a href="/2018/03/28/ThreadSafe/"  title="线程安全中的各种锁">
 <strong>下一篇：</strong><br/> 
 <span>线程安全中的各种锁
</span>
</a>
</div>

</nav>

	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS（30）</a></li>
		  
		
		  
			<li><a href="/categories/macOS/" title="macOS">macOS（1）</a></li>
		  
		
		  
			<li><a href="/categories/爱好/" title="爱好">爱好（4）</a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/多线程/" title="多线程">多线程<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/CocoaPods/" title="CocoaPods">CocoaPods<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/零散/" title="零散">零散<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/UI/" title="UI">UI<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/网络/" title="网络">网络<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/数据存储/" title="数据存储">数据存储<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/block/" title="block">block<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/内存管理/" title="内存管理">内存管理<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/音视频/" title="音视频">音视频<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/OpenGL-ES-2-0/" title="OpenGL ES 2.0">OpenGL ES 2.0<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/RunLoop/" title="RunLoop">RunLoop<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Runtime/" title="Runtime">Runtime<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>1</sup></a></li>
			
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

	<p class="copyright" style="margin-top: 10px;">
	Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2021
	
	<a href="/about" target="_blank" title="取名很蛋疼">取名很蛋疼</a>
	

	</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-28029597-1', 'null');  
ga('send', 'pageview');
</script>





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
